#include <video.h>
#include <types.h>
#include <heapmngr.h>
#include <kutils.h>
#include <proc.h>
#include <sched.h>
volatile task_t *current_task;
volatile task_t *ready_queue;
volatile bool task_switching = true;
const u16 TIMER_HZ = 100;
void exit();
u32 counter = 0;
u32 volatile pid = 0;
#define TASK_RUNNING (1 << 0)
#define TASK_SLEEPING (1 << 1)
#define KERNEL_STACK_SIZE  8192
void _task_initialize(void)
{
	__asm__ __volatile__("cli");
	current_task = ready_queue = (task_t*)kmalloc(sizeof(task_t));
	memset((task_t *)current_task, 0, sizeof(task_t));
	current_task->id = pid++;
    current_task->esp = 0;
    current_task->eip = 0;
    current_task->privilege = 0;
    current_task->state = 1;
    current_task->next = 0;
    current_task->type = THREAD;
    current_task->priority = PRIO_HIGH;
    current_task->time_to_run = 100;
    current_task->ready_to_run = 1;
	current_task->kernel_stack = (u32)kmalloc(KERNEL_STACK_SIZE)+KERNEL_STACK_SIZE;
	scheduler_install();
	insert_current_task(current_task);
	__asm__ __volatile__("sti");
}

void _get_task_stack(task_t *new_task,void (*entry)(),size_t argc, char** argv,u8 privilege, int priority)
{
	__asm__ __volatile__("cli");

	new_task->kernel_stack = kmalloc(KERNEL_STACK_SIZE)+KERNEL_STACK_SIZE;
	regs_t *kernel_stack = (regs_t*)new_task->kernel_stack;
    
    new_task->priority = priority;
	switch(new_task->priority)
	{
	case PRIO_DEAD:
	new_task->time_to_run = 0;
	break;
	case PRIO_IDLE:
	new_task->time_to_run = 30;
	break;
	case PRIO_LOW:
	new_task->time_to_run = 50;
	break;
	case PRIO_HIGH:
	new_task->time_to_run = 100;
	break;
	default:
	new_task->time_to_run = 100;
	break;
	}
    
    task_t *tmp_task = (task_t*)ready_queue;
	while(tmp_task->next)
	{
		tmp_task = tmp_task->next;
	}
	tmp_task->next = new_task;
      
    u32 code_segment = 0x08, data_segment = 0x10;
	kernel_stack->useresp =  (u32)&exit;
	kernel_stack->eflags = 0x0202;
	kernel_stack->cs = code_segment;
	kernel_stack->eip = (u32)entry;
	kernel_stack->err_code = 0;
	kernel_stack->int_no = 0;
	kernel_stack->eax = argc;
	kernel_stack->ecx = argv;
	kernel_stack->edx = 0;
	kernel_stack->ebx = 0;
	kernel_stack->ebp = 0;
	kernel_stack->esi = 0;
	kernel_stack->edi = 0;

	if(privilege == 3) data_segment = 0x23;
	kernel_stack->ds = data_segment;
	kernel_stack->es = data_segment;
	kernel_stack->fs = data_segment;
	kernel_stack->gs = data_segment;
	
	new_task->esp = (u32)kernel_stack;
	task_switching = true;
	insert_current_task(new_task);
		
	counter++;
	__asm__ __volatile__("sti");

}

u32 _task_switch(u32 esp)
{
	
	if(!current_task) return esp;
	if(current_task->priority == PRIO_LOW)
		current_task->time_to_run = 3;
   
    if( current_task->priority == PRIO_IDLE)
		current_task->time_to_run = 2;
		
	if( current_task->priority == PRIO_HIGH)
		current_task->time_to_run = 4;
			
	current_task->esp = esp;
	
	task_t *old_task = current_task;
	current_task = get_current_task();
	if(old_task == current_task)
		return esp;
	volatile task_t *t;
	for (t = ready_queue; t != 0; t = t->next){
  if (t->state == TASK_SLEEPING && t->wakeup_time <= gettickcount()){
t->wakeup_time = 0;
t->state = TASK_RUNNING;
  }
  
}

while (current_task != 0 && current_task->state == TASK_SLEEPING) {
        
               current_task = current_task->next;
               
                }
	
	if(!current_task)
		current_task = ready_queue;
	/*set_kernel_stack(current_task->kernel_stack+KERNEL_STACK_SIZE);*/
	return current_task->esp;
}

void create_v86_task()
{
	
}

void create_user_task()
{
	
}

void create_kernel_task(void (*thread)())
{
	task_t* new_task = kmalloc(sizeof(task_t));
	_get_task_stack(new_task,thread,0,0,0,PRIO_HIGH);
}

void create_process()
{
	
}

void switch_context() 
 {
 	if(switch_current_task())
 	__asm__ volatile("int $0x20");
 	else 
 	{
 	__asm__ volatile("hlt");
 	__asm__ volatile("int $0x20");
 	}
}
 



void exit()
{
    __asm__ __volatile__("cli");
	current_task->priority = PRIO_DEAD;
	current_task->time_to_run = 0;
    current_task->ready_to_run = 0;
    task_t* tmp_task = (task_t*)ready_queue;
    do
    {
        if(tmp_task->next == current_task)
        {
            tmp_task->next = current_task->next;
        }
        if(tmp_task->next)
        {
            tmp_task = tmp_task->next;
        }
    }
    while (tmp_task->next);
	delete_current_task(current_task);
  
    free((void *)((u32)current_task->kernel_stack - KERNEL_STACK_SIZE)); 
    free((void *)current_task);

  
    
    __asm__ __volatile__("sti");
	counter--;
	task_switching = 1;
    switch_context(); 
    
}


 void sleep2(u32 milliseconds) {


const u32 start_ticks = gettickcount();
kprint("%d",start_ticks);
u32 ticks_to_wait = milliseconds / (1000 / TIMER_HZ);

if (ticks_to_wait == 0)
ticks_to_wait = 1;
/* Mark the task as sleeping */
current_task->state = TASK_SLEEPING;
current_task->wakeup_time = start_ticks + ticks_to_wait;

 /* Force a task switch */
__asm__ __volatile__("int $0x20");
}
void task1()
{	

	kprint("TEST");	
	

}
void task3()
{	

	kprint("TASKEN");	
	

}
void task2()
{
	
 sleep2(9000);
	kprint("MUU");

}

void TASK_testing()
{
	create_kernel_task(task1);
	create_kernel_task(task2);	
	create_kernel_task(task3);	
}
